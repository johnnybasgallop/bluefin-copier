// services/dispatcher/main.go
package main

import (
	"context"
	"encoding/json"
	"log"

	"github.com/go-redis/redis/v8"

	// internal packages
	"github.com/johnnybasgallop/bluefin-copier/connectors"
	"github.com/johnnybasgallop/bluefin-copier/internal/config"
	"github.com/johnnybasgallop/bluefin-copier/internal/types"
)

// Entry point for the Dispatcher Service
func main() {
	// 1. Create a cancellable context (useful for graceful shutdown)
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// 2. Load config (to get subscriber definitions and credentials)
	cfg, err := config.Load("configs/config.yaml")
	if err != nil {
		log.Fatalf("failed to load config: %v", err)
	}

	// 3. Initialize the connectors pool with all subscriber accounts
	//    This will create one SlaveConnector per subscriber
	pool, err := connectors.NewPool(cfg.Subscribers)
	if err != nil {
		log.Fatalf("failed to initialize connector pool: %v", err)
	}

	// 4. Connect to Redis for pub/sub communication
	rdb := redis.NewClient(&redis.Options{
		Addr: "localhost:6379",
	})

	// 5. Subscribe to the "copier:commands" channel
	//    This channel carries CopyOrder messages generated by the copier
	pubsub := rdb.Subscribe(ctx, "copier:commands")
	defer pubsub.Close()

	// 6. Wait for subscription to be acknowledged by Redis
	if _, err := pubsub.Receive(ctx); err != nil {
		log.Fatalf("subscribe to copier:commands failed: %v", err)
	}
	log.Println("dispatcher subscribed to copier:commands, awaiting orders...")

	// 7. Obtain the Go channel to receive incoming messages
	ch := pubsub.Channel()

	// 8. Main loop: process each CopyOrder message
	for {
		select {
		case <-ctx.Done():
			// Context cancelled; perform any cleanup if necessary
			log.Println("dispatcher shutting down")
			return

		case msg, ok := <-ch:
			if !ok {
				// Channel closed unexpectedly
				log.Println("dispatcher: subscription channel closed")
				return
			}

			// 8a. Deserialize the JSON payload into a CopyOrder struct
			var order types.CopyOrder
			if err := json.Unmarshal([]byte(msg.Payload), &order); err != nil {
				log.Printf("invalid CopyOrder JSON: %v", err)
				continue // skip malformed message
			}

			// 8b. Lookup the corresponding SlaveConnector for this subscriber
			conn, err := pool.Get(order.SubscriberID)
			if err != nil {
				log.Printf("no connector for subscriber %s: %v", order.SubscriberID, err)
				continue // cannot execute without connector
			}

			// 8c. Send the order to the broker via the connector
			if err := conn.SendOrder(ctx, order); err != nil {
				log.Printf("failed to send order for subscriber %s: %v", order.SubscriberID, err)
				// TODO: implement retry logic or dead-letter queue
				continue
			}

			// 8d. Log success
			log.Printf("order executed for %s: Action=%s Symbol=%s Volume=%.2f",
				order.SubscriberID, order.Action, order.Symbol, order.Volume)
		}
	}
}
